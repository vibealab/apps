<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Analyzer with Histogram Manager</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #fff;
            padding: 20px;
        }

        .canvas { height: 200px; }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #00d4ff;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }

        .panel {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel h2 {
            margin-bottom: 15px;
            color: #00d4ff;
            font-size: 1.2rem;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 15px;
        }

        .btn {
            background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            color: #fff;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 212, 255, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6c5ce7 0%, #a29bfe 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a5a 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #00b894 0%, #00cec9 100%);
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input-wrapper input[type="file"] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }

        .canvas-container {
            position: relative;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        canvas {
            display: block;
            width: 100%;
        }

        .selection-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
        }

        .visualizers {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 900px) {
            .visualizers {
                grid-template-columns: 1fr;
            }
        }

        .histogram-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .histogram-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            margin-bottom: 8px;
            transition: all 0.3s ease;
        }

        .histogram-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .histogram-item.selected {
            background: rgba(0, 212, 255, 0.2);
            border: 1px solid #00d4ff;
        }

        .histogram-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .histogram-item .info {
            flex: 1;
        }

        .histogram-item .name {
            font-weight: bold;
            margin-bottom: 3px;
        }

        .histogram-item .meta {
            font-size: 12px;
            color: #888;
        }

        .histogram-item .preview {
            width: 100px;
            height: 40px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }

        .histogram-item .actions {
            display: flex;
            gap: 5px;
        }

        .histogram-item .btn {
            padding: 5px 10px;
            font-size: 12px;
        }

        .group-container {
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
        }

        .group-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 15px;
            background: rgba(108, 92, 231, 0.3);
            cursor: pointer;
        }

        .group-header:hover {
            background: rgba(108, 92, 231, 0.4);
        }

        .group-content {
            padding: 10px;
        }

        .group-content.collapsed {
            display: none;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .input-group input {
            flex: 1;
            padding: 10px 15px;
            border: none;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 14px;
        }

        .input-group input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .audio-info {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            font-size: 14px;
            color: #aaa;
        }

        .audio-info span {
            background: rgba(0, 0, 0, 0.3);
            padding: 5px 10px;
            border-radius: 5px;
        }

        .playback-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 10px;
        }

        .time-display {
            font-family: monospace;
            font-size: 14px;
            color: #00d4ff;
        }

        .progress-bar {
            flex: 1;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            cursor: pointer;
            position: relative;
        }

        .progress-bar .progress {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #0099cc);
            border-radius: 3px;
            width: 0%;
        }

        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }

        .tab {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: #fff;
            cursor: pointer;
            border-radius: 10px 10px 0 0;
            transition: all 0.3s ease;
        }

        .tab.active {
            background: rgba(0, 212, 255, 0.3);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .empty-state svg {
            width: 64px;
            height: 64px;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: #1a1a2e;
            padding: 30px;
            border-radius: 15px;
            max-width: 500px;
            width: 90%;
        }

        .modal-content h3 {
            margin-bottom: 20px;
            color: #00d4ff;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(0, 212, 255, 0.5);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 212, 255, 0.7);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéµ Audio Analyzer with Histogram Manager</h1>

        <!-- Audio Loading Panel -->
        <div class="panel">
            <h2>üìÅ Audio File</h2>
            <div class="controls">
                <div class="file-input-wrapper">
                    <button class="btn">
                        <span>üìÇ</span> Load Audio File
                    </button>
                    <input type="file" id="audioFile" accept="audio/*">
                </div>
                <button class="btn btn-secondary" id="playPauseBtn" disabled>
                    <span id="playPauseIcon">‚ñ∂Ô∏è</span> <span id="playPauseText">Play</span>
                </button>
                <button class="btn btn-secondary" id="stopBtn" disabled>
                    ‚èπÔ∏è Stop
                </button>
            </div>
            <div class="audio-info" id="audioInfo" style="display: none;">
                <span id="fileName">File: -</span>
                <span id="duration">Duration: -</span>
                <span id="sampleRate">Sample Rate: -</span>
            </div>
            <div class="playback-controls" id="playbackControls" style="display: none;">
                <span class="time-display" id="currentTime">00:00</span>
                <div class="progress-bar" id="progressBar">
                    <div class="progress" id="progress"></div>
                </div>
                <span class="time-display" id="totalTime">00:00</span>
            </div>
        </div>

        <!-- Visualization Panel -->
        <div class="panel">
            <h2>üìä Visualization</h2>
            <p style="margin-bottom: 10px; color: #888; font-size: 14px;">
                Click and drag on the waveform to select a portion for analysis
            </p>
            
            <!-- Waveform -->
            <div class="canvas-container">
                <canvas class="canvas" id="waveformCanvas" height="150"></canvas>
                <div class="selection-info" id="selectionInfo" style="display: none;">
                    Selection: <span id="selectionRange">-</span>
                </div>
            </div>

            <div class="visualizers">
                <!-- Full Spectrum -->
                <div>
                    <h3 style="margin-bottom: 10px; font-size: 14px;">Full Audio Spectrum</h3>
                    <div class="canvas-container">
                        <canvas class="canvas" id="histogramCanvas" height="200"></canvas>
                    </div>
                </div>
                
                <!-- Selection Spectrum -->
                <div>
                    <h3 style="margin-bottom: 10px; font-size: 14px;">Selection Spectrum</h3>
                    <div class="canvas-container">
                        <canvas class="canvas" id="selectionHistogramCanvas" height="200"></canvas>
                    </div>
                </div>
            </div>

            <div class="controls" style="margin-top: 15px;">
                <button class="btn btn-success" id="saveHistogramBtn" disabled>
                    üíæ Save Current Histogram
                </button>
                <button class="btn btn-success" id="saveSelectionBtn" disabled>
                    üíæ Save Selection Histogram
                </button>
                <button class="btn btn-secondary" id="clearSelectionBtn" disabled>
                    ‚úñÔ∏è Clear Selection
                </button>
            </div>
        </div>

        <!-- Saved Histograms Panel -->
        <div class="panel">
            <h2>üìö Saved Histograms</h2>
            
            <div class="tabs">
                <button class="tab active" data-tab="all">All Histograms</button>
                <button class="tab" data-tab="groups">Groups</button>
            </div>

            <!-- All Histograms Tab -->
            <div class="tab-content active" id="tab-all">
                <div class="controls">
                    <button class="btn btn-secondary" id="groupSelectedBtn" disabled>
                        üìÅ Group Selected
                    </button>
                    <button class="btn btn-danger" id="deleteSelectedBtn" disabled>
                        üóëÔ∏è Delete Selected
                    </button>
                    <button class="btn" id="selectAllBtn">
                        ‚òëÔ∏è Select All
                    </button>
                    <button class="btn" id="deselectAllBtn">
                        ‚òê Deselect All
                    </button>
                </div>
                <div class="histogram-list" id="histogramList">
                    <div class="empty-state">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3" />
                        </svg>
                        <p>No saved histograms yet</p>
                        <p style="font-size: 12px;">Load an audio file and save histograms to see them here</p>
                    </div>
                </div>
            </div>

            <!-- Groups Tab -->
            <div class="tab-content" id="tab-groups">
                <div class="input-group">
                    <input type="text" id="newGroupName" placeholder="Enter new group name...">
                    <button class="btn" id="createGroupBtn">‚ûï Create Group</button>
                </div>
                <div id="groupsList">
                    <div class="empty-state">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
                        </svg>
                        <p>No groups created yet</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Group Modal -->
    <div class="modal" id="groupModal">
        <div class="modal-content">
            <h3>Add to Group</h3>
            <p style="margin-bottom: 15px;">Select a group or create a new one:</p>
            <div id="groupSelectList"></div>
            <div class="input-group" style="margin-top: 15px;">
                <input type="text" id="modalNewGroupName" placeholder="Or create new group...">
                <button class="btn btn-success" id="modalCreateGroupBtn">Create</button>
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" id="closeModalBtn">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== IndexedDB Setup ====================
        class HistogramDB {
            constructor() {
                this.dbName = 'AudioHistogramDB';
                this.dbVersion = 1;
                this.db = null;
            }

            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.dbVersion);

                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve(this.db);
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;

                        // Histograms store
                        if (!db.objectStoreNames.contains('histograms')) {
                            const histogramStore = db.createObjectStore('histograms', { 
                                keyPath: 'id', 
                                autoIncrement: true 
                            });
                            histogramStore.createIndex('name', 'name', { unique: false });
                            histogramStore.createIndex('groupId', 'groupId', { unique: false });
                            histogramStore.createIndex('createdAt', 'createdAt', { unique: false });
                        }

                        // Groups store
                        if (!db.objectStoreNames.contains('groups')) {
                            const groupStore = db.createObjectStore('groups', { 
                                keyPath: 'id', 
                                autoIncrement: true 
                            });
                            groupStore.createIndex('name', 'name', { unique: true });
                        }
                    };
                });
            }

            async addHistogram(histogram) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['histograms'], 'readwrite');
                    const store = transaction.objectStore('histograms');
                    const request = store.add({
                        ...histogram,
                        createdAt: new Date().toISOString(),
                        groupId: null
                    });
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async getAllHistograms() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['histograms'], 'readonly');
                    const store = transaction.objectStore('histograms');
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async updateHistogram(id, updates) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['histograms'], 'readwrite');
                    const store = transaction.objectStore('histograms');
                    const getRequest = store.get(id);
                    
                    getRequest.onsuccess = () => {
                        const histogram = { ...getRequest.result, ...updates };
                        const putRequest = store.put(histogram);
                        putRequest.onsuccess = () => resolve(histogram);
                        putRequest.onerror = () => reject(putRequest.error);
                    };
                    getRequest.onerror = () => reject(getRequest.error);
                });
            }

            async deleteHistogram(id) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['histograms'], 'readwrite');
                    const store = transaction.objectStore('histograms');
                    const request = store.delete(id);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }

            async addGroup(name) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['groups'], 'readwrite');
                    const store = transaction.objectStore('groups');
                    const request = store.add({ name, createdAt: new Date().toISOString() });
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async getAllGroups() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['groups'], 'readonly');
                    const store = transaction.objectStore('groups');
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async deleteGroup(id) {
                return new Promise(async (resolve, reject) => {
                    // First, ungroup all histograms in this group
                    const histograms = await this.getAllHistograms();
                    const transaction = this.db.transaction(['histograms', 'groups'], 'readwrite');
                    
                    const histogramStore = transaction.objectStore('histograms');
                    for (const histogram of histograms) {
                        if (histogram.groupId === id) {
                            histogram.groupId = null;
                            histogramStore.put(histogram);
                        }
                    }

                    const groupStore = transaction.objectStore('groups');
                    groupStore.delete(id);
                    
                    transaction.oncomplete = () => resolve();
                    transaction.onerror = () => reject(transaction.error);
                });
            }

            async assignToGroup(histogramIds, groupId) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['histograms'], 'readwrite');
                    const store = transaction.objectStore('histograms');
                    
                    histogramIds.forEach(id => {
                        const getRequest = store.get(id);
                        getRequest.onsuccess = () => {
                            const histogram = getRequest.result;
                            histogram.groupId = groupId;
                            store.put(histogram);
                        };
                    });
                    
                    transaction.oncomplete = () => resolve();
                    transaction.onerror = () => reject(transaction.error);
                });
            }

            async removeFromGroup(histogramIds) {
                return this.assignToGroup(histogramIds, null);
            }
        }

        // ==================== Audio Analyzer Class ====================
        class AudioAnalyzer {
            constructor() {
                this.audioContext = null;
                this.analyser = null;
                this.source = null;
                this.audioBuffer = null;
                this.isPlaying = false;
                this.startTime = 0;
                this.pauseTime = 0;
                this.animationId = null;
                
                // Canvas elements
                this.waveformCanvas = document.getElementById('waveformCanvas');
                this.histogramCanvas = document.getElementById('histogramCanvas');
                this.selectionHistogramCanvas = document.getElementById('selectionHistogramCanvas');
                
                this.waveformCtx = this.waveformCanvas.getContext('2d');
                this.histogramCtx = this.histogramCanvas.getContext('2d');
                this.selectionHistogramCtx = this.selectionHistogramCanvas.getContext('2d');
                
                // Selection state
                this.selection = null;
                this.isSelecting = false;
                this.selectionStart = 0;
                
                // Current histogram data
                this.currentHistogramData = null;
                this.selectionHistogramData = null;
                
                this.setupCanvases();
                this.setupEventListeners();
            }

            setupCanvases() {
                const resize = () => {
                    const dpr = window.devicePixelRatio || 1;
                    
                    [this.waveformCanvas, this.histogramCanvas, this.selectionHistogramCanvas].forEach(canvas => {
                        const rect = canvas.getBoundingClientRect();
                        canvas.width = rect.width * dpr;
                        canvas.height = rect.height * dpr;
                        const ctx = canvas.getContext('2d');
                        ctx.scale(dpr, dpr);
                    });
                    
                    if (this.audioBuffer) {
                        this.drawWaveform();
                    }
                };
                
                resize();
                window.addEventListener('resize', resize);
            }

            setupEventListeners() {
                // Waveform selection
                this.waveformCanvas.addEventListener('mousedown', (e) => this.startSelection(e));
                this.waveformCanvas.addEventListener('mousemove', (e) => this.updateSelection(e));
                this.waveformCanvas.addEventListener('mouseup', (e) => this.endSelection(e));
                this.waveformCanvas.addEventListener('mouseleave', (e) => this.endSelection(e));
                
                // Touch support
                this.waveformCanvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.startSelection(e.touches[0]);
                });
                this.waveformCanvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.updateSelection(e.touches[0]);
                });
                this.waveformCanvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.endSelection(e.changedTouches[0]);
                });
            }

            async loadAudio(file) {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                const arrayBuffer = await file.arrayBuffer();
                this.audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                
                // Setup analyser
                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = 2048;
                this.analyser.smoothingTimeConstant = 0.8;
                
                // Update UI
                document.getElementById('fileName').textContent = `File: ${file.name}`;
                document.getElementById('duration').textContent = `Duration: ${this.formatTime(this.audioBuffer.duration)}`;
                document.getElementById('sampleRate').textContent = `Sample Rate: ${this.audioBuffer.sampleRate} Hz`;
                document.getElementById('totalTime').textContent = this.formatTime(this.audioBuffer.duration);
                document.getElementById('audioInfo').style.display = 'flex';
                document.getElementById('playbackControls').style.display = 'flex';
                
                // Enable buttons
                document.getElementById('playPauseBtn').disabled = false;
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('saveHistogramBtn').disabled = false;
                
                // Draw waveform
                this.drawWaveform();
                
                // Compute and draw initial histogram from audio data
                this.computeStaticHistogram();
                
                return this.audioBuffer;
            }

            computeStaticHistogram() {
                // Compute frequency histogram from the audio buffer data
                const channelData = this.audioBuffer.getChannelData(0);
                const fftSize = 2048;
                const numBins = fftSize / 2;
                
                // Simple approximation: compute magnitude spectrum from segments
                const histogramData = new Float32Array(numBins);
                const segmentSize = Math.floor(channelData.length / 10);
                
                for (let seg = 0; seg < 10; seg++) {
                    const start = seg * segmentSize;
                    const segment = channelData.slice(start, start + fftSize);
                    
                    // Apply simple FFT approximation (using energy in frequency bands)
                    for (let i = 0; i < numBins; i++) {
                        let sum = 0;
                        const bandStart = Math.floor(i * segment.length / numBins);
                        const bandEnd = Math.floor((i + 1) * segment.length / numBins);
                        for (let j = bandStart; j < bandEnd && j < segment.length; j++) {
                            sum += Math.abs(segment[j]);
                        }
                        histogramData[i] += sum / (bandEnd - bandStart || 1);
                    }
                }
                
                // Normalize
                const max = Math.max(...histogramData);
                for (let i = 0; i < numBins; i++) {
                    histogramData[i] = (histogramData[i] / max) * 255;
                }
                
                this.currentHistogramData = histogramData;
                this.drawHistogram(this.histogramCtx, this.histogramCanvas, histogramData, '#00d4ff');
            }

            play() {
                if (this.isPlaying) return;
                
                this.source = this.audioContext.createBufferSource();
                this.source.buffer = this.audioBuffer;
                this.source.connect(this.analyser);
                this.analyser.connect(this.audioContext.destination);
                
                this.source.onended = () => {
                    if (this.isPlaying) {
                        this.stop();
                    }
                };
                
                const offset = this.pauseTime;
                this.source.start(0, offset);
                this.startTime = this.audioContext.currentTime - offset;
                this.isPlaying = true;
                
                this.updateVisualization();
            }

            pause() {
                if (!this.isPlaying) return;
                
                this.pauseTime = this.audioContext.currentTime - this.startTime;
                this.source.stop();
                this.source.disconnect();
                this.isPlaying = false;
                
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
            }

            stop() {
                if (this.source) {
                    try {
                        this.source.stop();
                        this.source.disconnect();
                    } catch (e) {}
                }
                
                this.isPlaying = false;
                this.pauseTime = 0;
                this.startTime = 0;
                
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
                
                document.getElementById('progress').style.width = '0%';
                document.getElementById('currentTime').textContent = '00:00';
                
                // Reset to static histogram
                this.computeStaticHistogram();
            }

            updateVisualization() {
                if (!this.isPlaying) return;
                
                const currentTime = this.audioContext.currentTime - this.startTime;
                const progress = (currentTime / this.audioBuffer.duration) * 100;
                
                document.getElementById('progress').style.width = `${Math.min(progress, 100)}%`;
                document.getElementById('currentTime').textContent = this.formatTime(currentTime);
                
                // Get frequency data
                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                this.analyser.getByteFrequencyData(dataArray);
                
                this.currentHistogramData = dataArray;
                this.drawHistogram(this.histogramCtx, this.histogramCanvas, dataArray, '#00d4ff');
                
                // Update waveform playhead
                this.drawWaveform(currentTime);
                
                this.animationId = requestAnimationFrame(() => this.updateVisualization());
            }

            drawWaveform(playheadTime = null) {
                const canvas = this.waveformCanvas;
                const ctx = this.waveformCtx;
                const rect = canvas.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height;
                
                ctx.clearRect(0, 0, width, height);
                
                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(0, 0, width, height);
                
                if (!this.audioBuffer) return;
                
                const data = this.audioBuffer.getChannelData(0);
                const step = Math.ceil(data.length / width);
                const amp = height / 2;
                
                // Draw selection highlight
                if (this.selection) {
                    const startX = (this.selection.start / this.audioBuffer.duration) * width;
                    const endX = (this.selection.end / this.audioBuffer.duration) * width;
                    
                    ctx.fillStyle = 'rgba(0, 212, 255, 0.3)';
                    ctx.fillRect(startX, 0, endX - startX, height);
                }
                
                // Draw waveform
                ctx.beginPath();
                ctx.moveTo(0, amp);
                
                for (let i = 0; i < width; i++) {
                    let min = 1.0;
                    let max = -1.0;
                    
                    for (let j = 0; j < step; j++) {
                        const datum = data[(i * step) + j];
                        if (datum < min) min = datum;
                        if (datum > max) max = datum;
                    }
                    
                    ctx.lineTo(i, (1 + min) * amp);
                    ctx.lineTo(i, (1 + max) * amp);
                }
                
                ctx.strokeStyle = '#00d4ff';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Draw playhead
                if (playheadTime !== null) {
                    const playheadX = (playheadTime / this.audioBuffer.duration) * width;
                    ctx.beginPath();
                    ctx.moveTo(playheadX, 0);
                    ctx.lineTo(playheadX, height);
                    ctx.strokeStyle = '#ff6b6b';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                // Draw selection borders
                if (this.selection) {
                    const startX = (this.selection.start / this.audioBuffer.duration) * width;
                    const endX = (this.selection.end / this.audioBuffer.duration) * width;
                    
                    ctx.beginPath();
                    ctx.moveTo(startX, 0);
                    ctx.lineTo(startX, height);
                    ctx.moveTo(endX, 0);
                    ctx.lineTo(endX, height);
                    ctx.strokeStyle = '#00d4ff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }

            drawHistogram(ctx, canvas, data, color) {
                const rect = canvas.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height;
                
                ctx.clearRect(0, 0, width, height);
                
                // Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(0, 0, width, height);
                
                if (!data || data.length === 0) return;
                
                const barWidth = width / data.length;
                const gradient = ctx.createLinearGradient(0, height, 0, 0);
                gradient.addColorStop(0, color);
                gradient.addColorStop(0.5, '#6c5ce7');
                gradient.addColorStop(1, '#ff6b6b');
                
                ctx.fillStyle = gradient;
                
                for (let i = 0; i < data.length; i++) {
                    const barHeight = (data[i] / 255) * height;
                    const x = i * barWidth;
                    const y = height - barHeight;
                    
                    ctx.fillRect(x, y, barWidth - 1, barHeight);
                }
                
                // Draw frequency labels
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.font = '10px sans-serif';
                const labels = ['0Hz', '1kHz', '5kHz', '10kHz', '20kHz'];
                const positions = [0, 0.05, 0.25, 0.5, 1];
                
                positions.forEach((pos, i) => {
                    const x = pos * width;
                    ctx.fillText(labels[i], x + 2, height - 5);
                });
            }

            startSelection(e) {
                if (!this.audioBuffer) return;
                
                const rect = this.waveformCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const ratio = x / rect.width;
                
                this.isSelecting = true;
                this.selectionStart = ratio * this.audioBuffer.duration;
                this.selection = {
                    start: this.selectionStart,
                    end: this.selectionStart
                };
            }

            updateSelection(e) {
                if (!this.isSelecting || !this.audioBuffer) return;
                
                const rect = this.waveformCanvas.getBoundingClientRect();
                const x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
                const ratio = x / rect.width;
                const time = ratio * this.audioBuffer.duration;
                
                this.selection = {
                    start: Math.min(this.selectionStart, time),
                    end: Math.max(this.selectionStart, time)
                };
                
                this.drawWaveform();
                this.updateSelectionInfo();
            }

            endSelection(e) {
                if (!this.isSelecting) return;
                
                this.isSelecting = false;
                
                if (this.selection && this.selection.end - this.selection.start > 0.01) {
                    this.computeSelectionHistogram();
                    document.getElementById('saveSelectionBtn').disabled = false;
                    document.getElementById('clearSelectionBtn').disabled = false;
                } else {
                    this.clearSelection();
                }
            }

            clearSelection() {
                this.selection = null;
                this.selectionHistogramData = null;
                this.drawWaveform();
                
                // Clear selection histogram
                const ctx = this.selectionHistogramCtx;
                const rect = this.selectionHistogramCanvas.getBoundingClientRect();
                ctx.clearRect(0, 0, rect.width, rect.height);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(0, 0, rect.width, rect.height);
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Select a portion of the waveform', rect.width / 2, rect.height / 2);
                
                document.getElementById('selectionInfo').style.display = 'none';
                document.getElementById('saveSelectionBtn').disabled = true;
                document.getElementById('clearSelectionBtn').disabled = true;
            }

            updateSelectionInfo() {
                if (!this.selection) return;
                
                const info = document.getElementById('selectionInfo');
                const range = document.getElementById('selectionRange');
                
                info.style.display = 'block';
                range.textContent = `${this.formatTime(this.selection.start)} - ${this.formatTime(this.selection.end)}`;
            }

            computeSelectionHistogram() {
                if (!this.selection || !this.audioBuffer) return;
                
                const sampleRate = this.audioBuffer.sampleRate;
                const startSample = Math.floor(this.selection.start * sampleRate);
                const endSample = Math.floor(this.selection.end * sampleRate);
                const channelData = this.audioBuffer.getChannelData(0);
                
                // Extract selection
                const selectionData = channelData.slice(startSample, endSample);
                
                // Compute FFT-like histogram
                const numBins = 256;
                const histogramData = new Float32Array(numBins);
                
                // Simple energy-based frequency estimation
                const segmentSize = Math.max(1, Math.floor(selectionData.length / numBins));
                
                for (let i = 0; i < numBins; i++) {
                    let energy = 0;
                    const start = i * segmentSize;
                    const end = Math.min(start + segmentSize, selectionData.length);
                    
                    for (let j = start; j < end; j++) {
                        energy += Math.abs(selectionData[j]);
                    }
                    
                    histogramData[i] = energy / (end - start || 1);
                }
                
                // Normalize to 0-255
                const max = Math.max(...histogramData);
                for (let i = 0; i < numBins; i++) {
                    histogramData[i] = (histogramData[i] / max) * 255;
                }
                
                this.selectionHistogramData = histogramData;
                this.drawHistogram(this.selectionHistogramCtx, this.selectionHistogramCanvas, histogramData, '#6c5ce7');
            }

            getHistogramData(isSelection = false) {
                const data = isSelection ? this.selectionHistogramData : this.currentHistogramData;
                if (!data) return null;
                
                return {
                    data: Array.from(data),
                    selection: isSelection ? { ...this.selection } : null,
                    duration: this.audioBuffer.duration,
                    sampleRate: this.audioBuffer.sampleRate
                };
            }

            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
        }

        // ==================== Main Application ====================
        class App {
            constructor() {
                this.db = new HistogramDB();
                this.analyzer = new AudioAnalyzer();
                this.selectedHistograms = new Set();
                this.currentFileName = '';
                
                this.init();
            }

            async init() {
                await this.db.init();
                this.setupEventListeners();
                this.refreshHistogramList();
                this.refreshGroupsList();
                
                // Initialize selection histogram canvas with placeholder
                this.analyzer.clearSelection();
            }

            setupEventListeners() {
                // File input
                document.getElementById('audioFile').addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        this.currentFileName = file.name;
                        await this.analyzer.loadAudio(file);
                    }
                });

                // Playback controls
                document.getElementById('playPauseBtn').addEventListener('click', () => {
                    if (this.analyzer.isPlaying) {
                        this.analyzer.pause();
                        document.getElementById('playPauseIcon').textContent = '‚ñ∂Ô∏è';
                        document.getElementById('playPauseText').textContent = 'Play';
                    } else {
                        this.analyzer.play();
                        document.getElementById('playPauseIcon').textContent = '‚è∏Ô∏è';
                        document.getElementById('playPauseText').textContent = 'Pause';
                    }
                });

                document.getElementById('stopBtn').addEventListener('click', () => {
                    this.analyzer.stop();
                    document.getElementById('playPauseIcon').textContent = '‚ñ∂Ô∏è';
                    document.getElementById('playPauseText').textContent = 'Play';
                });

                // Progress bar click
                document.getElementById('progressBar').addEventListener('click', (e) => {
                    if (!this.analyzer.audioBuffer) return;
                    
                    const rect = e.target.getBoundingClientRect();
                    const ratio = (e.clientX - rect.left) / rect.width;
                    const time = ratio * this.analyzer.audioBuffer.duration;
                    
                    const wasPlaying = this.analyzer.isPlaying;
                    if (wasPlaying) this.analyzer.pause();
                    
                    this.analyzer.pauseTime = time;
                    document.getElementById('progress').style.width = `${ratio * 100}%`;
                    document.getElementById('currentTime').textContent = this.analyzer.formatTime(time);
                    
                    if (wasPlaying) this.analyzer.play();
                });

                // Save histogram buttons
                document.getElementById('saveHistogramBtn').addEventListener('click', () => {
                    this.saveHistogram(false);
                });

                document.getElementById('saveSelectionBtn').addEventListener('click', () => {
                    this.saveHistogram(true);
                });

                document.getElementById('clearSelectionBtn').addEventListener('click', () => {
                    this.analyzer.clearSelection();
                });

                // Tab switching
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                        
                        e.target.classList.add('active');
                        document.getElementById(`tab-${e.target.dataset.tab}`).classList.add('active');
                    });
                });

                // Selection actions
                document.getElementById('selectAllBtn').addEventListener('click', () => {
                    document.querySelectorAll('.histogram-item input[type="checkbox"]').forEach(cb => {
                        cb.checked = true;
                        this.selectedHistograms.add(parseInt(cb.dataset.id));
                    });
                    this.updateSelectionButtons();
                });

                document.getElementById('deselectAllBtn').addEventListener('click', () => {
                    document.querySelectorAll('.histogram-item input[type="checkbox"]').forEach(cb => {
                        cb.checked = false;
                    });
                    this.selectedHistograms.clear();
                    this.updateSelectionButtons();
                });

                document.getElementById('groupSelectedBtn').addEventListener('click', () => {
                    this.showGroupModal();
                });

                document.getElementById('deleteSelectedBtn').addEventListener('click', () => {
                    this.deleteSelectedHistograms();
                });

                // Group creation
                document.getElementById('createGroupBtn').addEventListener('click', () => {
                    const name = document.getElementById('newGroupName').value.trim();
                    if (name) {
                        this.createGroup(name);
                        document.getElementById('newGroupName').value = '';
                    }
                });

                // Modal
                document.getElementById('closeModalBtn').addEventListener('click', () => {
                    document.getElementById('groupModal').classList.remove('active');
                });

                document.getElementById('modalCreateGroupBtn').addEventListener('click', async () => {
                    const name = document.getElementById('modalNewGroupName').value.trim();
                    if (name) {
                        const groupId = await this.createGroup(name);
                        await this.db.assignToGroup(Array.from(this.selectedHistograms), groupId);
                        document.getElementById('groupModal').classList.remove('active');
                        document.getElementById('modalNewGroupName').value = '';
                        this.selectedHistograms.clear();
                        this.refreshHistogramList();
                        this.refreshGroupsList();
                    }
                });
            }

            async saveHistogram(isSelection) {
                const histogramData = this.analyzer.getHistogramData(isSelection);
                if (!histogramData) return;

                const name = prompt('Enter a name for this histogram:', 
                    isSelection ? `${this.currentFileName} (selection)` : this.currentFileName);
                
                if (!name) return;

                await this.db.addHistogram({
                    name,
                    fileName: this.currentFileName,
                    isSelection,
                    ...histogramData
                });

                this.refreshHistogramList();
            }

            async refreshHistogramList() {
                const histograms = await this.db.getAllHistograms();
                const groups = await this.db.getAllGroups();
                const container = document.getElementById('histogramList');

                if (histograms.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3" />
                            </svg>
                            <p>No saved histograms yet</p>
                            <p style="font-size: 12px;">Load an audio file and save histograms to see them here</p>
                        </div>
                    `;
                    return;
                }

                container.innerHTML = histograms.map(h => {
                    const group = groups.find(g => g.id === h.groupId);
                    return `
                        <div class="histogram-item ${this.selectedHistograms.has(h.id) ? 'selected' : ''}">
                            <input type="checkbox" data-id="${h.id}" ${this.selectedHistograms.has(h.id) ? 'checked' : ''}>
                            <canvas class="preview" data-histogram='${JSON.stringify(h.data)}'></canvas>
                            <div class="info">
                                <div class="name">${h.name}</div>
                                <div class="meta">
                                    ${h.isSelection ? `Selection: ${this.formatTime(h.selection.start)} - ${this.formatTime(h.selection.end)}` : 'Full audio'}
                                    ${group ? ` | Group: ${group.name}` : ''}
                                </div>
                            </div>
                            <div class="actions">
                                ${h.groupId ? `<button class="btn btn-secondary" onclick="app.removeFromGroup(${h.id})">Ungroup</button>` : ''}
                                <button class="btn btn-danger" onclick="app.deleteHistogram(${h.id})">üóëÔ∏è</button>
                            </div>
                        </div>
                    `;
                }).join('');

                // Draw mini histograms
                container.querySelectorAll('.preview').forEach(canvas => {
                    const data = JSON.parse(canvas.dataset.histogram);
                    this.drawMiniHistogram(canvas, data);
                });

                // Setup checkbox listeners
                container.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                    cb.addEventListener('change', (e) => {
                        const id = parseInt(e.target.dataset.id);
                        if (e.target.checked) {
                            this.selectedHistograms.add(id);
                        } else {
                            this.selectedHistograms.delete(id);
                        }
                        e.target.closest('.histogram-item').classList.toggle('selected', e.target.checked);
                        this.updateSelectionButtons();
                    });
                });
            }

            drawMiniHistogram(canvas, data) {
                const ctx = canvas.getContext('2d');
                const width = 100;
                const height = 40;
                
                canvas.width = width * 2;
                canvas.height = height * 2;
                ctx.scale(2, 2);
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, width, height);
                
                const barWidth = width / data.length;
                ctx.fillStyle = '#00d4ff';
                
                for (let i = 0; i < data.length; i++) {
                    const barHeight = (data[i] / 255) * height;
                    ctx.fillRect(i * barWidth, height - barHeight, barWidth, barHeight);
                }
            }

            async refreshGroupsList() {
                const groups = await this.db.getAllGroups();
                const histograms = await this.db.getAllHistograms();
                const container = document.getElementById('groupsList');

                if (groups.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
                            </svg>
                            <p>No groups created yet</p>
                        </div>
                    `;
                    return;
                }

                container.innerHTML = groups.map(group => {
                    const groupHistograms = histograms.filter(h => h.groupId === group.id);
                    return `
                        <div class="group-container">
                            <div class="group-header" onclick="app.toggleGroup(this)">
                                <span>üìÅ ${group.name} (${groupHistograms.length} items)</span>
                                <div>
                                    <button class="btn btn-danger" onclick="event.stopPropagation(); app.deleteGroup(${group.id})">üóëÔ∏è Delete Group</button>
                                </div>
                            </div>
                            <div class="group-content">
                                ${groupHistograms.length === 0 ? '<p style="color: #666; padding: 10px;">No histograms in this group</p>' :
                                    groupHistograms.map(h => `
                                        <div class="histogram-item">
                                            <canvas class="preview" data-histogram='${JSON.stringify(h.data)}'></canvas>
                                            <div class="info">
                                                <div class="name">${h.name}</div>
                                                <div class="meta">${h.isSelection ? 'Selection' : 'Full audio'}</div>
                                            </div>
                                            <button class="btn btn-secondary" onclick="app.removeFromGroup(${h.id})">Remove</button>
                                        </div>
                                    `).join('')
                                }
                            </div>
                        </div>
                    `;
                }).join('');

                // Draw mini histograms
                container.querySelectorAll('.preview').forEach(canvas => {
                    const data = JSON.parse(canvas.dataset.histogram);
                    this.drawMiniHistogram(canvas, data);
                });
            }

            toggleGroup(header) {
                header.nextElementSibling.classList.toggle('collapsed');
            }

            async createGroup(name) {
                try {
                    const id = await this.db.addGroup(name);
                    this.refreshGroupsList();
                    return id;
                } catch (e) {
                    alert('A group with this name already exists');
                    return null;
                }
            }

            async deleteGroup(id) {
                if (confirm('Delete this group? Histograms will be ungrouped but not deleted.')) {
                    await this.db.deleteGroup(id);
                    this.refreshHistogramList();
                    this.refreshGroupsList();
                }
            }

            async deleteHistogram(id) {
                if (confirm('Delete this histogram?')) {
                    await this.db.deleteHistogram(id);
                    this.selectedHistograms.delete(id);
                    this.refreshHistogramList();
                    this.refreshGroupsList();
                }
            }

            async deleteSelectedHistograms() {
                if (this.selectedHistograms.size === 0) return;
                
                if (confirm(`Delete ${this.selectedHistograms.size} selected histogram(s)?`)) {
                    for (const id of this.selectedHistograms) {
                        await this.db.deleteHistogram(id);
                    }
                    this.selectedHistograms.clear();
                    this.refreshHistogramList();
                    this.refreshGroupsList();
                    this.updateSelectionButtons();
                }
            }

            async removeFromGroup(id) {
                await this.db.removeFromGroup([id]);
                this.refreshHistogramList();
                this.refreshGroupsList();
            }

            async showGroupModal() {
                const groups = await this.db.getAllGroups();
                const container = document.getElementById('groupSelectList');
                
                container.innerHTML = groups.map(g => `
                    <div class="histogram-item" onclick="app.assignToGroup(${g.id})" style="cursor: pointer;">
                        <span>üìÅ ${g.name}</span>
                    </div>
                `).join('') || '<p style="color: #666;">No groups available. Create one below.</p>';
                
                document.getElementById('groupModal').classList.add('active');
            }

            async assignToGroup(groupId) {
                await this.db.assignToGroup(Array.from(this.selectedHistograms), groupId);
                document.getElementById('groupModal').classList.remove('active');
                this.selectedHistograms.clear();
                this.refreshHistogramList();
                this.refreshGroupsList();
                this.updateSelectionButtons();
            }

            updateSelectionButtons() {
                const hasSelection = this.selectedHistograms.size > 0;
                document.getElementById('groupSelectedBtn').disabled = !hasSelection;
                document.getElementById('deleteSelectedBtn').disabled = !hasSelection;
            }

            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
        }

        // Initialize the app
        const app = new App();
    </script>
</body>
</html>
